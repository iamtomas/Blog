![image](https://user-images.githubusercontent.com/83901620/127632240-36d87179-f0d2-4b52-9a4c-09235642fd12.png)



## 1) 乐观锁和悲观锁

**乐观锁**

定义：在操作数据时比较乐观，认为别人不会不会同时修改数据，只是在更新时判断这期间有没人修改，如果有，则放弃继续操作

实现方式：**CAS** 或 **版本号**

CAS (Compare And Swap) 

主要有三部分：1）需要读写的内存位置  2）预期值  3）写入的新值

CAS 原理：如果内存位置的值等于预期的值，则将该位置更新为新值，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。

注：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。

**悲观锁**

定义：在操作数据时比较悲观，认为别人会同时修改数据，因此操作数据时直接给数据锁住，直到操作完成后才释放


**实践**

可通过 **开启1000个线程来实现自增的方式** 比较 乐观锁(CAS) 和 悲观锁 以及 没进行任何线程安全方面保护的对象，会发现除了 乐观锁 和 悲观锁 没问题，其他的偏少

**优缺点和适用场景**

- 乐观锁适用的场景受到了更多的限制（如CAS只能保证**单个**变量操作的原子性，版本号不能解决多表的情况）
- 竞争不激烈，乐观锁更有优势，因为悲观锁会锁住代码块或数据，其他线程无法同时访问，影响并发，而且加锁和释放锁都需要消耗额外的资源；竞争激烈时，乐观锁在执行更新时频繁失败，需要不断重试，浪费CPU资源

**拓展**

CAS 有哪些缺点

- ABA 问题
- 高竞争下的开销问题（频繁重试）
- 功能限制（只能保证单个变量操作的原子性）

参考：https://www.cnblogs.com/kismetv/p/10787228.html


## 2) 索引

**定义**

官方：是帮助 MYSQL 高效获取数据的**数据结构**

目的是在于提高查询效率，可以类比字典。我们可以理解为排好序的快速查找的数据结构（影响 where 和 order by）

注：一般来说索引本身很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上

**优势**

类似图书馆的书目索引，提高数据检索的效率，降低数据库的 IO 成本

通过索引列对数据进行排序，降低数据排序的成本，降低了 CPU 的消耗

**劣势**

降低了更新表的速度，进行 insert、update 和 delete，MYSQL 不仅要更新保存数据，还要保存更新索引文件

**索引分类**

- 单值索引
- 唯一索引：索引列的值必须唯一
- 复合索引

**命令**

添加索引

``` sql

ALTER TABLE table ADD PRIMARY KEY (column_list)
ALTER TABLE table ADD UNIQUE index_name (column_list)
ALTER TABLE table ADD INDEX index_name (column_list)
ALTER TABLE table ADD FULLTEXT index_name (column_list)

```

**索引结构**

- BTREE （重点）
- HASH
- full-text
- R-Tree

**哪些情况适合建索引**

- 主键自动建立唯一索引
- 频繁作为查询条件的字段
- 查询中与其他表关联的字段
- 频繁更新不适合建索引
- where条件用不到的字段不创建
- 单键、组合索引的选择问题（高并发下倾向组合索引）
- 查询中排序的字段
- 查询中统计或分组字段
- **差不多三百万级数据量可以开始考虑建索引了**

**哪些情况不适合建索引**

- 记录太少
- 经常增删改
- 重复且分布平均的表字段（区分度不高，比如只存在 t 或者 f）

注：假如一个表有10万记录，有一个字段只有 t 和 f 两种值，分布概率为50%，那么这种字段建索引一般不会提高数据库的查询速度。索引的选择性是指索引列中不同值的数目与表中记录数的比，越接近，则效率越高

**性能分析**

- MYSQL QUERY optimizer
- EXPLAIN  

**索引优化**
